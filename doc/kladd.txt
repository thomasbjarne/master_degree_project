interface newton_div_diff_interpolate
		module procedure :: newton_div_diff_interpolate_kind32, &
							newton_div_diff_interpolate_kind64
	end interface newton_div_diff_interpolate

pure function newton_div_diff_interpolate_kind32(pointset, x) result(Px)

	real(real32), intent(in) 									:: x
	real(real32), intent(in), dimension(:,:) 					:: pointset
	real(real32) 												:: Px
	real(real32), dimension(size(pointset,1),size(pointset,1)) 	:: a
	real(real32), dimension(size(pointset,1)) 					:: cofactors
	integer 													:: i, j, n

	a = 0
	n = size(pointset,1)
	do j = 1, n
		a(j,1) = pointset(j,2)
	end do

	do i = 2, n
		do j = 1, n+1-i
			a(j,i) = ( a(j+1,i-1) - a(j,i-1) )/&
					 ( pointset(j+i-1,1)-pointset(j,1) )
		end do
	end do

	Px 				= 0
	cofactors(1) 	= 1
	do i = 2, n
		cofactors(i) = cofactors(i-1)*(x-pointset(i-1,1))
	end do
	do i = 1, n
		Px = Px + (a(1,i)*cofactors(i))
	end do

end function newton_div_diff_interpolate_kind32

pure function newton_div_diff_interpolate_kind64(pointset, x) result(Px)

	real(real64), intent(in) 									:: x
	real(real64), intent(in), dimension(:,:) 					:: pointset
	real(real64) 												:: Px
	real(real64), dimension(size(pointset,1),size(pointset,1)) 	:: a
	real(real64), dimension(size(pointset,1)) 					:: cofactors
	integer 													:: i, j, n

	a = 0
	n = size(pointset,1)
	do j = 1, n
		a(j,1) = pointset(j,2)
	end do

	do i = 2, n
		do j = 1, n+1-i
			a(j,i) = ( a(j+1,i-1) - a(j,i-1) )/&
					 ( pointset(j+i-1,1)-pointset(j,1) )
		end do
	end do

	Px 				= 0
	cofactors(1) 	= 1
	do i = 2, n
		cofactors(i) = cofactors(i-1)*(x-pointset(i-1,1))
	end do
	do i = 1, n
		Px = Px + (a(1,i)*cofactors(i))
	end do

end function newton_div_diff_interpolate_kind64


pure function chebyshev_roots(a, b, n) result(roots)

	real, intent(in) 	:: a, b
	integer, intent(in) :: n
	real, dimension(n) 	:: roots
	real, parameter 	:: pi = 3.14159265358979323846
	integer 			:: i

	do i = 1, n
		roots(i) = (b-a)/2 + ((b-a)/2)*cos((2*i-1)*pi)/2*n
	end do

end function chebyshev_roots

pure function legendre_roots(a, b, n) result(roots)

	real, intent(in) 	:: a, b
	integer, intent(in) :: n
	real, dimension(n) 	:: roots
	integer 			:: i
	
	do i = 1, n
		roots(i) = (b-a)/2 + ((b-a)/2)*2
	end do

end function legendre_roots

-------------------------------------------

	!taylor series of u(x,y,0)|p_i = f(x,y)|p_i with error O(h^5) is 
	!= f(p_i) + d_xf(p_i)(x-x_i) + d_yf(p_i)(y-y_i) + d_x^2f(p_i)(x-x_i)^2/2
	!+ d_xd_yf(p_i)(x-x_i)(y-y_i) + d_y^2f(p_i)(y-y_i)^2/2 
	!+ d_x^3f(p_i)(x-x_i)^3/6 + d_x^2d_yf(p_i)(x-x_i)^2(y-y_i)/2 
	!+ d_xd_y^2f(p_i)(x-x_i)(y-y_i)^2/2 + d_y^3f(p_i)(y-y_i)^3/6 
	!+ d_x^4f(p_i)(x-x_i)^4/24 + d_x^3d_yf(p_i)(x-x_i)^3(y-y_i)/6 
	!+ d_x^2d_y^2f(p_i)(x-x_i)^2(y-y_i)^2/4 + d_xd_y^3f(p_i)(x-x_i)(y-y_i)^3/6 
	!+ d_y^4f(p_i)(y-y_i)^4/24
	
-------------------------------------------


pure function Ri(indexnum, coeffs, grid, x, y) result(riofxy)

	integer, intent(in)				:: indexnum
	real, intent(in), dimension(:) 	:: coeffs
	real, intent(in) 				:: x, y
	type(triangulation)				:: grid
	real, dimension(:), allocatable :: pbasisvec
	real							:: xi, yi
	integer							:: N, i
	
	N = size(coeffs,1)
	xi = grid%barycenters(indexnum, 1)
	yi = grid%barycenters(indexnum, 2)
	allocate(pbasisvec(N))
	do i = 1, N
		pbasisvec(i) = [1, 
	end do
	
	
	contains
	
	pure function riofxy(x, y) result(res)
	
		real, intent(in) :: x, y
		real			 :: res
		
		res = 
	
	end function riofxy

end function Ri

----------------------------------

pure function triangle_neighbours(connectivity_list) result(neighbours)

	integer, intent(in), dimension(:,:)		:: connectivity_list
	integer, dimension(:,:), allocatable	:: neighbours
	logical, dimension(:), allocatable		:: maskvec
	integer									:: N, i, j, l
	
	N = size(connectivity_list,1)
	allocate(neighbours(N,3), maskvec(N))
	neighbours	= 0
	maskvec		= .true.
	do i = 1, N
		maskvec(i) = .false.
		do j = 1, 2
			do l = 1, N
				if ((grid%connectivity_list(i,j)== &
					grid%connectivity_list(l,1) .or. &
					grid%connectivity_list(i,j)== &
					grid%connectivity_list(l,2) .or. &
					grid%connectivity_list(i,j)== &
					grid%connectivity_list(l,3)) .and. &
					((grid%connectivity_list(i,j+1)== &
					grid%connectivity_list(l,1) .or. &
					grid%connectivity_list(i,j+1)== &
					grid%connectivity_list(l,2) .or. &
					grid%connectivity_list(i,j+1)== &
					grid%connectivity_list(l,3)) .and. &
					maskvec(l).eqv. .true.)) then
					neighbours(i,j) = l
				end if
			end do
		end do
		do l = 1, N
				if ((grid%connectivity_list(i,3)== &
					grid%connectivity_list(l,1) .or. &
					grid%connectivity_list(i,3)== &
					grid%connectivity_list(l,2) .or. &
					grid%connectivity_list(i,3)== &
					grid%connectivity_list(l,3)) .and. &
					((grid%connectivity_list(i,1)== &
					grid%connectivity_list(l,1) .or. &
					grid%connectivity_list(i,1)== &
					grid%connectivity_list(l,2) .or. &
					grid%connectivity_list(i,1)== &
					grid%connectivity_list(l,3)) .and. &
					maskvec(l).eqv. .true.)) then
					neighbours(i,3) = l
				end if
			end do
		maskvec = .true.
	end do

end function triangle_neighbours

--------------------------

	!identify boundaryvolumes
	allocate(boundaryvolumes(N))
	boundaryvolumes = .false.
	do i = 1, N
		do j = 1, 3
			if (grid%points(grid%connectivity_list(i,j),1) == 0 .or. &
				grid%points(grid%connectivity_list(i,j),1) == 1 .or. &
				grid%points(grid%connectivity_list(i,j),2) == 0 .or. &
				grid%points(grid%connectivity_list(i,j),2) == 1) then
				boundaryvolumes(i) = .true.
			end if
		end do 
	end do
	
------------------------------

pure function constrained_lsqr_kind32(A, b) result(x)

	!constraint is that C^T=row(1) of A satisfies C^Tx = b(1)
	real(real32), intent(in), dimension(:,:) 	:: A
	real(real32), intent(in), dimension(:)		:: b
	real(real32), dimension(:), allocatable		:: x, temp1, temp2
	real(real32), dimension(:,:), allocatable 	:: Q1, R1, C, A_tilde
	integer										:: m, n
	
	m = size(A,1)
	n = size(A,2)
	allocate (x(n),C(n,1),Q1(n,n),R1(n,1),A_tilde(m,n),temp1(n),temp2(n))
	C(:,1) = A(1,:)
	call reduced_qr_decomposition(C, Q1, R1)
	A_tilde = matmul(A, Q1)
	temp1 	= backwards_subst(R1, b)
	temp2 	= least_squares_qr(A_tilde, (b-matmul(A_tilde, temp1)))
	x		= matmul(Q1, [temp1, temp2])

end function constrained_lsqr_kind32

pure function constrained_lsqr_kind64(A, b) result(x)

	!constraint is that C^T=row(1) of A satisfies C^Tx = b(1)
	real(real64), intent(in), dimension(:,:) 	:: A
	real(real64), intent(in), dimension(:)		:: b
	real(real64), dimension(:), allocatable		:: x, temp1, temp2
	real(real64), dimension(:,:), allocatable 	:: Q1, R1, C, A_tilde
	integer										:: m, n
	
	m = size(A,1)
	n = size(A,2)
	allocate (x(n),C(n,1),Q1(n,n),R1(n,1),A_tilde(m,n),temp1(n),temp2(n))
	C(:,1) = A(1,:)
	call reduced_qr_decomposition(C, Q1, R1)
	A_tilde = matmul(A, Q1)
	temp1 	= backwards_subst(R1, b)
	temp2 	= least_squares_qr(A_tilde, (b-matmul(A_tilde, temp1)))
	x		= matmul(Q1, [temp1, temp2])

end function constrained_lsqr_kind64

------------------------------------

    interface constrained_lsqr
    	module procedure :: constrained_lsqr_kind32, constrained_lsqr_kind64
    end interface constrained_lsqr
    
----------------------------------

pure function constrained_least_squares_kind64(A, b, C, d) result(x)
	
	!ref: ucla notes

	real(real64), intent(in), dimension(:,:)	:: A, C
	real(real64), intent(in), dimension(:)		:: b, d
	real(real64), dimension(:), allocatable		:: x, combined_vec, new_b
	real(real64), dimension(:,:), allocatable	:: combined_matrix
	integer										:: m, n, p
	
	m = size(A,1)
	n = size(A,2)
	p = size(C,1)
	allocate (x(n), combined_vec(n+p), combined_matrix(n+p,n+p), new_b(n+p))
	combined_matrix				 = 0
	combined_matrix(1:n,1:n) 	 = 2*matmul(transpose(A),A)
	combined_matrix(n+1:n+p,1:n) = C
	combined_matrix(1:n,n+1:n+p) = transpose(C)
	
	new_b(1:n) 		= matmul(transpose(A),b)
	new_b(n+1:n+p)  = d
	
	combined_vec	= gaussian_elim(combined_matrix, new_b)
	x 				= combined_vec(1:n)

end function constrained_least_squares_kind64

-------------------------------

pure subroutine arnoldi_iteration_kind32(A, n, Q, H)

	real(real32), intent(in), dimension(:,:) 				:: A
	integer, intent(in) 									:: n
	real(real32), intent(out), dimension(size(A,1), n+1) 	:: Q
	real(real32), intent(out), dimension(n+1, n) 			:: H
	real(real32), dimension(size(A,1)) 						:: b
	real(real32) 											:: eps
	integer 												:: i, j

	b 		= 1
	Q 		= 0
	H 		= 0
	eps 	= 1e-10
	Q(:, 1) = b/norm2(b)
	do j = 1, n
		Q(:,j+1) 	 = matmul(A, Q(:, j))
		do i = 1, j
		    H(i, j)  = dot_product(Q(:,j+1),Q(:,i))
		    Q(:,j+1) = Q(:,j+1) - H(i, j) * Q(:,i)
		end do
		H(j+1, j) 	 = norm2(Q(:,j+1))
		Q(:,j+1) 	 = Q(:,j+1)/H(j+1,j)
		if (H(j+1,j) < eps) exit
	end do

end subroutine arnoldi_iteration_kind32

pure subroutine arnoldi_iteration_kind64(A, n, Q, H)

	real(real64), intent(in), dimension(:,:) 				:: A
	integer, intent(in) 									:: n
	real(real64), intent(out), dimension(size(A,1), n+1) 	:: Q
	real(real64), intent(out), dimension(n+1, n) 			:: H
	real(real64), dimension(size(A,1)) 						:: b
	real(real64) 											:: eps
	integer 												:: i, j

	b 		= 1
	Q 		= 0
	H 		= 0
	eps 	= 1e-10
	Q(:, 1) = b/norm2(b)
	do j = 1, n
		Q(:,j+1) 	 = matmul(A, Q(:, j))
		do i = 1, j
		    H(i, j)  = dot_product(Q(:,j+1),Q(:,i))
		    Q(:,j+1) = Q(:,j+1) - H(i, j) * Q(:,i)
		end do
		H(j+1, j)	 = norm2(Q(:,j+1))
		Q(:,j+1) 	 = Q(:,j+1)/H(j+1,j)
		if (H(j+1,j) < eps) exit
	end do

end subroutine arnoldi_iteration_kind64

------------------------------------------

pure function upper_hessenberg_kind32(A) result(H)

	real(real32), intent(in), dimension(:,:) 		:: A
	real(real32), dimension(size(A,1), size(A,2)) 	:: Q, H, ID
	real(real32), dimension(:), allocatable 		:: u
	real(real32) 									:: alpha
	integer 										:: i, m, n, j

	m 	= size(A,1)
	n	= size(A,2)
	ID 	= identity_matrix(m,n)
	H 	= A
	do i = 1, n-2
		allocate( u(n - i) )
		alpha 						= norm2( H(i+1:n,i) )
		if (H(i+1,i) < 0) alpha 	= - alpha
		u 							= H(i+1:n, i) + alpha * ID(i+1:n, i+1) 
		if (norm2(u) /= 0) u 		= u / norm2( u )
		Q 							= ID
		Q(i+1:n, i+1:n) 			= Q(i+1:n, i+1:n) - &
										2 * vec_outer_product(u, u)
		H(i+1:n, i:n) 				= matmul(Q(i+1:n, i+1:n), H(i+1:n, i:n))
		H(1:n, i+1:n) 				= matmul(H(1:n, i+1:n), &
											 transpose(Q(i+1:n, i+1:n)))
		deallocate(u)
	end do

end function upper_hessenberg_kind32

pure function upper_hessenberg_kind64(A) result(H)

	real(real64), intent(in), dimension(:,:) 		:: A
	real(real64), dimension(size(A,1), size(A,2)) 	:: Q, H, ID
	real(real64), dimension(:), allocatable 		:: u
	real(real64) 									:: alpha
	integer 										:: i, m, n, j

	m 	= size(A,1)
	n	= size(A,2)
	ID 	= identity_matrix(m,n)
	H 	= A
	do i = 1, n-2
		allocate( u(n - i) )
		alpha 						= norm2( H(i+1:n,i) )
		if (H(i+1,i) < 0) alpha 	= - alpha
		u 							= H(i+1:n, i) + alpha * ID(i+1:n, i+1) 
		if (norm2(u) /= 0) u 		= u / norm2( u )
		Q 							= ID
		Q(i+1:n, i+1:n) 			= Q(i+1:n, i+1:n) - &
										2 * vec_outer_product(u, u)
		H(i+1:n, i:n) 				= matmul(Q(i+1:n, i+1:n), H(i+1:n, i:n))
		H(1:n, i+1:n) 				= matmul(H(1:n, i+1:n), &
											 transpose(Q(i+1:n, i+1:n)))
		deallocate(u)
	end do

end function upper_hessenberg_kind64

----------------------------
    interface qr_algorithm
        module procedure :: qr_algorithm_kind32, qr_algorithm_kind64
    end interface qr_algorithm

pure function qr_algorithm_kind32(A) result(A_schur)

	real(real32), intent(in), dimension(:,:)  	:: A
	real(real32), dimension(:,:), allocatable 	:: A_schur, A_k, Q_k, R_k, H
	real(real32), parameter 					:: tol = 1e-14
	real(real32) 								:: mu
	integer 									:: m, n, count

	count 	= 0
	m 		= size(A,1)
	allocate(A_schur(m,m), H(m,m))

	n 		= m
	H 		= upper_hessenberg(A)
	do while (n > 1)
		allocate (A_k(1:n,1:n), Q_k(1:n,1:n), R_k(1:n,1:n))
		A_k(1:n,1:n) 	= H(1:n,1:n)
		do while (maxval(abs(A_k(n, 1:n-1))) > tol .and. count < 1500)
			count 		= count + 1
			mu 			= A_k(n,n)
			A_k 		= A_k - mu*identity_matrix(m,n)
			call reduced_qr_decomposition(A_k, Q_k, R_k)
			A_k 		= matmul(R_k, Q_k) + mu*identity_matrix(m,n)
		end do
		A_schur(1:n,1:n)= A_k
		n 				= n - 1
		deallocate(A_k, Q_k, R_k)
	end do

end function qr_algorithm_kind32

pure function qr_algorithm_kind64(A) result(A_schur)

	real(real64), intent(in), dimension(:,:) 	:: A
	real(real64), dimension(:,:), allocatable 	:: A_schur, A_k, Q_k, R_k, H
	real(real64), parameter 					:: tol = 1e-14
	real(real64) 								:: mu
	integer 									:: m, n, count

	count 	= 0
	m 		= size(A,1)
	allocate(A_schur(m,m), H(m,m))

	n 		= m
	H 		= upper_hessenberg(A)
	do while (n > 1)
		allocate (A_k(1:n,1:n), Q_k(1:n,1:n), R_k(1:n,1:n))
		A_k(1:n,1:n) 	= H(1:n,1:n)
		do while (maxval(abs(A_k(n, 1:n-1))) > tol .and. count < 1500)
			count 		= count + 1
			mu 	= A_k(n,n)
			A_k 		= A_k - mu*identity_matrix(m,n)
			call reduced_qr_decomposition(A_k, Q_k, R_k)
			A_k 		= matmul(R_k, Q_k) + mu*identity_matrix(m,n)
		end do
		A_schur(1:n,1:n)= A_k
		n 				= n - 1
		deallocate(A_k, Q_k, R_k)
	end do
		
end function qr_algorithm_kind64



---------------------------------------------

pure subroutine mgs_qr_decomposition_kind32(A, Q, R)

	real(real32), intent(in), dimension(:,:)					:: A
	real(real32), intent(out), dimension(size(A,1),size(A,1)) 	:: Q
	real(real32), intent(out), dimension(size(A,1),size(A,2))	:: R
	real(real32), dimension(:,:), allocatable					:: v
	integer														:: i, j, n
	
	allocate(v(size(A,2), size(A,1)))
	n = size(A,2)
	do i = 1, n
		v(i,:) = A(:,i)
	end do
	do i = 1, n
		R(i,i) = norm2(v(i,:))
		Q(:,i) = v(i,:)/R(i,i)
		do j = i+1, n
			R(i,j) = dot_product(Q(:,i), v(j,:))
			v(j,:) = v(j,:) - R(i,j)*Q(:,i)
		end do
	end do

end subroutine mgs_qr_decomposition_kind32

pure subroutine mgs_qr_decomposition_kind64(A, Q, R)

	real(real64), intent(in), dimension(:,:)					:: A
	real(real64), intent(out), dimension(size(A,1),size(A,1)) 	:: Q
	real(real64), intent(out), dimension(size(A,1),size(A,2))	:: R
	real(real64), dimension(:,:), allocatable					:: v
	integer														:: i, j, n
	
	allocate(v(size(A,2), size(A,1)))
	n = size(A,2)
	do i = 1, n
		v(i,:) = A(:,i)
	end do
	do i = 1, n
		R(i,i) = norm2(v(i,:))
		Q(:,i) = v(i,:)/R(i,i)
		do j = i+1, n
			R(i,j) = dot_product(Q(:,i), v(j,:))
			v(j,:) = v(j,:) - R(i,j)*Q(:,i)
		end do
	end do
	
end subroutine mgs_qr_decomposition_kind64

------------------------------



-----------------------------------

pure function constrained_least_squares_kind32(A, b, C, d) result(x)
	
	!ref: ucla notes
	!constraint is: Cx = d

	real(real32), intent(in), dimension(:,:)	:: A, C
	real(real32), intent(in), dimension(:)		:: b, d
	real(real32), dimension(:), allocatable		:: x, combined_vec, u, v, y,w
	real(real32), dimension(:,:), allocatable	:: stacked_matrix, Q, Q1, &
													Q2, Q_tilde, R, R_tilde, Rt
	integer										:: m, n, p
	
	m = size(A,1)
	n = size(A,2)
	p = size(C,1)
	allocate (x(n), stacked_matrix(m+p,n), Q(m+p,m+p), R(m+p,n))
	stacked_matrix(1:m,:) 		= A
	stacked_matrix(m+1:m+p,:) 	= C
	call qr_decomposition(stacked_matrix, Q, R)
	
	allocate(Q1(m+p,m+p), Q2(m+p,m+p), Q_tilde(m+p,m+p), R_tilde(m+p,p))
	Q1 = Q(1:m,:)
	Q2 = Q(m+1:m+p,:)
	call qr_decomposition(transpose(Q2), Q_tilde, R_tilde)
	
	allocate(u(n), v(n), w(n), y(n), Rt(p, m+p))
	Rt= transpose(R_tilde)
	u = forwards_subst(Rt(:,1:p), d)
	v = matmul(matmul(transpose(Q_tilde),transpose(Q1)), b) - u
	w = backwards_subst(R_tilde, v)
	y = matmul(transpose(Q1), b) - matmul(transpose(Q2), w)
	x = backwards_subst(R, y)

end function constrained_least_squares_kind32

pure function constrained_least_squares_kind64(A, b, C, d) result(x)
	
	!ref: ucla notes
	!constraint is: Cx = d

	real(real64), intent(in), dimension(:,:)	:: A, C
	real(real64), intent(in), dimension(:)		:: b, d
	real(real64), dimension(:), allocatable		:: x, combined_vec, u, v, y,w
	real(real64), dimension(:,:), allocatable	:: stacked_matrix, Q, Q1, &
													Q2, Q_tilde, R, R_tilde, Rt
	integer										:: m, n, p
	
	m = size(A,1)
	n = size(A,2)
	p = size(C,1)
	allocate (x(n), stacked_matrix(m+p,n), Q(m+p,m+p), R(m+p,n))
	stacked_matrix(1:m,:) 		= A
	stacked_matrix(m+1:m+p,:) 	= C
	call qr_decomposition(stacked_matrix, Q, R)
	
	allocate(Q1(m,m+p), Q2(p,m+p), Q_tilde(m+p,m+p), R_tilde(m+p,p))
	Q1 = Q(1:m,:)
	Q2 = Q(m+1:m+p,:)
	call qr_decomposition(transpose(Q2), Q_tilde, R_tilde)
	
	allocate(u(p), v(p), w(n), y(n), Rt(p, m+p))
	Rt= transpose(R_tilde)
	u = forwards_subst(Rt, d)
	v = matmul(matmul(transpose(Q_tilde),transpose(Q1)), b) - u
	w = backwards_subst(R_tilde, v)
	y = matmul(transpose(Q1), b) - matmul(transpose(Q2), w)
	x = backwards_subst(R, y)


end function constrained_least_squares_kind64


pure function rref_kind32(A) result(U)

	real(real32), intent(in), dimension(:,:) 		:: A
	real(real32), dimension(size(A,1),size(A,2)) 	:: L, U, P, temp_u, &
							   						   temp_l, temp_p
	integer 										:: k, i, j, n, m

	m		= size(A,1)
	n 		= size(A,2)
	U 		= A
	temp_u 	= U
	L 		= identity_matrix(m,n)
	temp_l 	= L
	P 		= identity_matrix(m,n)
	temp_p 	= P

	do k = 1, n-1
		i 				= maxloc( U(:, k), dim=1 )
		U(k, k:n) 		= U(i, k:n)
		U(i, k:n) 		= temp_u(k, k:n)
		L(k, 1:k-1) 	= L(i, 1:k-1)
		L(i, 1:k-1) 	= temp_L(k, 1:k-1)
		P(k, :) 		= P(i, :)
		P(i, :) 		= temp_P(k, :)
		do j = k+1, n
		    L(j,k) 		= U(j,k) / U(k,k)
		    U(j, k:n) 	= U(j, k:n) - L(j,k) * U(k, k:n)
		end do
		temp_U = U
		temp_L = L
		temp_P = P
	end do

end function rref_kind32

pure function rref_kind64(A) result(U)

	real(real64), intent(in), dimension(:,:) 		:: A
	real(real64), dimension(size(A,1),size(A,2)) 	:: L, U, P, temp_u, &
							   						   temp_l, temp_p
	integer 										:: k, i, j, n, m

	m		= size(A,1)
	n 		= size(A,2)
	U 		= A
	temp_u 	= U
	L 		= identity_matrix(m,n)
	temp_l 	= L
	P 		= identity_matrix(m,n)
	temp_p 	= P

	do k = 1, n-1
		i 				= maxloc( U(:, k), dim=1 )
		U(k, k:n) 		= U(i, k:n)
		U(i, k:n) 		= temp_u(k, k:n)
		L(k, 1:k-1) 	= L(i, 1:k-1)
		L(i, 1:k-1) 	= temp_L(k, 1:k-1)
		P(k, :) 		= P(i, :)
		P(i, :) 		= temp_P(k, :)
		do j = k+1, n
		    L(j,k) 		= U(j,k) / U(k,k)
		    U(j, k:n) 	= U(j, k:n) - L(j,k) * U(k, k:n)
		end do
		temp_U = U
		temp_L = L
		temp_P = P
	end do

end function rref_kind64

---------------------

    
    interface gaussian_elim
        module procedure :: gaussian_elim_kind32, gaussian_elim_kind64
    end interface gaussian_elim
    
    
pure function gaussian_elim_kind32(A, b) result(x)

	real(real32), intent(in), dimension(:,:) 		:: A
	real(real32), intent(in), dimension(:) 			:: b
	real(real32), dimension(size(A,1),size(A,2)) 	:: L, U, P, temp_u, &
							   						   temp_l, temp_p
	real(real32), dimension(size(b)) 				:: x, y
	integer 										:: k, i, j, n, m

	m		= size(A,1)
	n 		= size(A,2)
	U 		= A
	temp_u 	= U
	L 		= identity_matrix(m,n)
	temp_l 	= L
	P 		= identity_matrix(m,n)
	temp_p 	= P

	do k = 1, n-1
		i 				= maxloc( U(:, k), dim=1 )
		U(k, k:n) 		= U(i, k:n)
		U(i, k:n) 		= temp_u(k, k:n)
		L(k, 1:k-1) 	= L(i, 1:k-1)
		L(i, 1:k-1) 	= temp_L(k, 1:k-1)
		P(k, :) 		= P(i, :)
		P(i, :) 		= temp_P(k, :)
		do j = k+1, n
		    L(j,k) 		= U(j,k) / U(k,k)
		    U(j, k:n) 	= U(j, k:n) - L(j,k) * U(k, k:n)
		end do
	end do

	y 		= forwards_subst(L, matmul(P, b))
	x 		= backwards_subst(U, y)

end function gaussian_elim_kind32

pure function gaussian_elim_kind64(A, b) result(x)

	real(real64), intent(in), dimension(:,:) 		:: A
	real(real64), intent(in), dimension(:) 			:: b
	real(real64), dimension(size(A,1),size(A,2)) 	:: L, U, P, temp_u, &
							   						   temp_l, temp_p
	real(real64), dimension(size(b)) 				:: x, y
	integer 										:: k, i, j, n, m

	m		= size(A,1)
	n 		= size(A,2)
	U 		= A
	temp_u 	= U
	L 		= identity_matrix(m,n)
	temp_l 	= L
	P 		= identity_matrix(m,n)
	temp_p 	= P

	do k = 1, n-1
		i 				= maxloc( U(:, k), dim=1 )
		U(k, k:n) 		= U(i, k:n)
		U(i, k:n) 		= temp_u(k, k:n)
		L(k, 1:k-1) 	= L(i, 1:k-1)
		L(i, 1:k-1) 	= temp_L(k, 1:k-1)
		P(k, :) 		= P(i, :)
		P(i, :) 		= temp_P(k, :)
		do j = k+1, n
		    L(j,k) 		= U(j,k) / U(k,k)
		    U(j, k:n) 	= U(j, k:n) - L(j,k) * U(k, k:n)
		end do
		temp_U = U
		temp_L = L
		temp_P = P
	end do

	y 		= forwards_subst(L, matmul(P,b))
	x 		= backwards_subst(U, y)

end function gaussian_elim_kind64


-----------------------------

do j = 1, N
		R_coeffs(j,:) = recon_coeffs_1d(rstencils(j,:), u, rmatrices(j,:,:),&
										partition, j)
end do

call write_to_file(R_coeffs(:,:),6)
	
-----------------------

if (partition%points(partition%intervals(i,2)) > &
		    partition%points(partition%intervals(i,1))) then
	do j = 1, 2
		if (j == 1) then
			res(i) = &
				centralflux(partition%points(partition%intervals(i,j)))
		else
			res(i) = res(i) - &
				centralflux(partition%points(partition%intervals(i,j)))
		end if
	end do
else
 	do j = 1, 2
		if (j == 1) then
			res(i) = &
				-centralflux(partition%points(partition%intervals(i,j)))
		else
			res(i) = res(i) + &
				centralflux(partition%points(partition%intervals(i,j)))
		end if
	end do
end if

-----------------------------

	pure function centralflux(x) result(fres)
	
		real(real64), intent(in)	:: x
		integer						:: N, m
		real(real64)				:: fres, Ri, Rj
		
		N  = size(R_coeffs,2)
		Ri = 0
		Rj = 0
		do m = 1, N
			Ri = Ri + R_coeffs(i,m)*((x-partition%midpoints(i))**degvec(m))
		end do
		if (partition%neighbours(i,j) == 0) then
				Rj  = Ri
		else
			do m = 1, N
				Rj = Rj + &
					R_coeffs(partition%neighbours(i,j),m)*&
					((x-partition%midpoints(partition%neighbours(i,j)))**&
					degvec(m))
			end do
		end if
		fres = (Ri+Rj)/2.

	end function centralflux
	
---------------------

!write to file scalar

subroutine write_to_file_scalar_logical(var, data_slot)
        
    logical, intent(in) 					:: var
    integer, intent(in) 					:: data_slot
    character(len=20) 						:: filename
    character(len=12) 						:: str
    integer 								:: i, fileunit

    write (str, *) data_slot
    str 		= adjustl(str)
    filename 	= 'data/datafile' // trim(str) // '.txt'
    filename 	= trim(filename)

    open(newunit=fileunit, file=filename, position='rewind', action='write')

    write(unit=fileunit, fmt=*) var

    close(unit=fileunit)

end subroutine write_to_file_scalar_logical

subroutine write_to_file_scalar_kind8_int(var, data_slot)
        
    integer(int8), intent(in) 				:: var
    integer, intent(in) 					:: data_slot
    character(len=20) 						:: filename
    character(len=12) 						:: str
    integer 								:: i, fileunit

    write (str, *) data_slot
    str 		= adjustl(str)
    filename 	= 'data/datafile' // trim(str) // '.txt'
    filename 	= trim(filename)

    open(newunit=fileunit, file=filename, position='rewind', action='write')

    write(unit=fileunit, fmt=*) var

    close(unit=fileunit)

end subroutine write_to_file_scalar_kind8_int

subroutine write_to_file_scalar_kind16_int(var, data_slot)
        
    integer(int16), intent(in) 					:: var
    integer, intent(in) 					 	:: data_slot
    character(len=20) 							:: filename
    character(len=12) 							:: str
    integer 									:: i, fileunit

    write (str, *) data_slot
    str 		= adjustl(str)
    filename 	= 'data/datafile' // trim(str) // '.txt'
    filename 	= trim(filename)

    open(newunit=fileunit, file=filename, position='rewind', action='write')

    write(unit=fileunit, fmt=*) var
    
    close(unit=fileunit)

end subroutine write_to_file_scalar_kind16_int

subroutine write_to_file_scalar_kind32_int(var, data_slot)
        
    integer(int32), intent(in) 					:: var
    integer, intent(in) 					 	:: data_slot
    character(len=20) 							:: filename
    character(len=12) 							:: str
    integer 									:: i, fileunit

    write (str, *) data_slot
    str 		= adjustl(str)
    filename 	= 'data/datafile' // trim(str) // '.txt'
    filename 	= trim(filename)

    open(newunit=fileunit, file=filename, position='rewind', action='write')

    write(unit=fileunit, fmt=*) var

    close(unit=fileunit)

end subroutine write_to_file_scalar_kind32_int

subroutine write_to_file_scalar_kind32_real(var, data_slot)
    
    real(real32), intent(in) 				:: var
    integer, intent(in) 					:: data_slot
    character(len=20) 						:: filename
    character(len=12) 						:: str
    integer 								:: i, fileunit

    write (str, *) data_slot
    str 		= adjustl(str)
    filename 	= 'data/datafile' // trim(str) // '.txt'
    filename 	= trim(filename)

    open(newunit=fileunit, file=filename, position='rewind', action='write')

    write(unit=fileunit, fmt=*) var

    close(unit=fileunit)

end subroutine write_to_file_scalar_kind32_real

subroutine write_to_file_scalar_kind64_real(var, data_slot)
    
    real(real64), intent(in) 				:: var
    integer, intent(in) 					:: data_slot
    character(len=20) 						:: filename
    character(len=12) 						:: str
    integer 								:: i, fileunit

    write (str, *) data_slot
    str 		= adjustl(str)
    filename 	= 'data/datafile' // trim(str) // '.txt'
    filename 	= trim(filename)

    open(newunit=fileunit, file=filename, position='rewind', action='write')

	write(unit=fileunit, fmt=*) var

    close(unit=fileunit)

end subroutine write_to_file_scalar_kind64_real

----------------------------

pure function centralflux(x) result(fres)

	real(real64), intent(in)	:: x
	integer						:: sigma, m
	real(real64)				:: fres, Ri, Rj
	
	!for periodic boundary
	
	sigma  = size(R_coeffs,2)
	Ri = 0
	Rj = 0
	do m = 1, sigma
		Ri = Ri + R_coeffs(i,m)*((x-partition%midpoints(i))**degvec(m))
	end do
	if (i == 1 .and. j == 1) then
		do m = 1, sigma
			Rj = Rj + &
				R_coeffs(N,m)*&
				((x-partition%midpoints(N))**&
				degvec(m))
		end do
	else if (i == N .and. j == 2) then
		do m = 1, sigma
			Rj = Rj + &
				R_coeffs(1,m)*&
				((x-partition%midpoints(1))**&
				degvec(m))
		end do
	else
		do m = 1, sigma
			Rj = Rj + &
				R_coeffs(partition%neighbours(i,j),m)*&
				((x-partition%midpoints(partition%neighbours(i,j)))**&
				degvec(m))
		end do
	end if
	fres = (Ri+Rj)/2.

end function centralflux

-------------------------------

	pure function centralflux(x) result(fres)
	
		real(real64), intent(in)	:: x
		integer						:: sigma, m
		real(real64)				:: fres, Ri, Rj
		
		!for ibvp
		
		sigma  = size(R_coeffs,2)
		Ri = 0
		Rj = 0
		do m = 1, sigma
			Ri = Ri + R_coeffs(i,m)*((x-partition%midpoints(i))**degvec(m))
		end do
		if (partition%neighbours(i,j) == 0) then
			Rj = Ri
		else
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(partition%neighbours(i,j),m)*&
					((x-partition%midpoints(partition%neighbours(i,j)))**&
					degvec(m))
			end do
		end if
		fres = (Ri+Rj)/2.

	end function centralflux
	
	
-------------------------------

if (fluxtype==1) then
		do i = 1, N
			if (partition%points(partition%intervals(i,2)) > &
				partition%points(partition%intervals(i,1))) then
				do j = 1, 2
					if (j == 1) then
						res(i) = &
							upwindflux(partition%points(&
										partition%intervals(i,j)))
					else
						res(i) = res(i) - &
							upwindflux(partition%points(&
										partition%intervals(i,j)))
					end if
				end do
			else
			 	do j = 1, 2
					if (j == 1) then
						res(i) = &
							-upwindflux(partition%points(&
										partition%intervals(i,j)))
					else
						res(i) = res(i) + &
							upwindflux(partition%points(&
										partition%intervals(i,j)))
					end if
				end do
			end if
		end do
	else if (fluxtype == 3) then
		do i = 1, N
			if (partition%points(partition%intervals(i,2)) > &
				partition%points(partition%intervals(i,1))) then
				do j = 1, 2
					if (j == 1) then
						res(i) = &
							centralflux(partition%points(&
										partition%intervals(i,j)))
					else
						res(i) = res(i) - &
							centralflux(partition%points(&
										partition%intervals(i,j)))
					end if
				end do
			else
			 	do j = 1, 2
					if (j == 1) then
						res(i) = &
							-centralflux(partition%points(&
										partition%intervals(i,j)))
					else
						res(i) = res(i) + &
							centralflux(partition%points(&
										partition%intervals(i,j)))
					end if
				end do
			end if
		end do
	else if (fluxtype == 4) then
		do i = 1, N
			if (partition%points(partition%intervals(i,2)) > &
				partition%points(partition%intervals(i,1))) then
				do j = 1, 2
					if (j == 1) then
						res(i) = &
							LFflux(partition%points(&
										partition%intervals(i,j)))
					else
						res(i) = res(i) - &
							LFflux(partition%points(&
										partition%intervals(i,j)))
					end if
				end do
			else
			 	do j = 1, 2
					if (j == 1) then
						res(i) = &
							-LFflux(partition%points(&
										partition%intervals(i,j)))
					else
						res(i) = res(i) + &
							LFflux(partition%points(&
										partition%intervals(i,j)))
					end if
				end do
			end if
		end do
	end if
	
------------------------

	pure function centralflux(x) result(fres)

		real(real64), intent(in)	:: x
		integer						:: sigma, m
		real(real64)				:: fres, Ri, Rj
		
		!for periodic boundary
		
		sigma  = size(R_coeffs,2)
		Ri = 0
		Rj = 0
		do m = 1, sigma
			Ri = Ri + R_coeffs(i,m)*((x-partition%midpoints(i))**degvec(m))
		end do
		if (i == 1 .and. j == 1) then
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(N,m)*&
					((x-partition%midpoints(N))**&
					degvec(m))
			end do
		else if (i == N .and. j == 2) then
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(1,m)*&
					((x-partition%midpoints(1))**&
					degvec(m))
			end do
		else
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(partition%neighbours(i,j),m)*&
					((x-partition%midpoints(partition%neighbours(i,j)))**&
					degvec(m))
			end do
		end if
		fres = (Ri+Rj)/2.

	end function centralflux
	
	pure function upwindflux(x) result(fres)

		real(real64), intent(in)	:: x
		integer						:: sigma, m
		real(real64)				:: fres, Ri, Rj
		
		!for periodic boundary
		
		sigma  = size(R_coeffs,2)
		Ri = 0
		Rj = 0
		do m = 1, sigma
			Ri = Ri + R_coeffs(i,m)*((x-partition%midpoints(i))**degvec(m))
		end do
		if (i == 1 .and. j == 1) then
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(N,m)*&
					((x-partition%midpoints(N))**&
					degvec(m))
			end do
		else if (i == N .and. j == 2) then
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(1,m)*&
					((x-partition%midpoints(1))**&
					degvec(m))
			end do
		else
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(partition%neighbours(i,j),m)*&
					((x-partition%midpoints(partition%neighbours(i,j)))**&
					degvec(m))
			end do
		end if
		if (j == 1) fres = Rj
		if (j == 2) fres = Ri

	end function upwindflux
	
	pure function LFflux(x) result(fres)

		real(real64), intent(in)	:: x
		integer						:: sigma, m
		real(real64)				:: fres, Ri, Rj
		
		!for periodic boundary
		
		sigma  = size(R_coeffs,2)
		Ri = 0
		Rj = 0
		do m = 1, sigma
			Ri = Ri + R_coeffs(i,m)*((x-partition%midpoints(i))**degvec(m))
		end do
		if (i == 1 .and. j == 1) then
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(N,m)*&
					((x-partition%midpoints(N))**&
					degvec(m))
			end do
		else if (i == N .and. j == 2) then
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(1,m)*&
					((x-partition%midpoints(1))**&
					degvec(m))
			end do
		else
			do m = 1, sigma
				Rj = Rj + &
					R_coeffs(partition%neighbours(i,j),m)*&
					((x-partition%midpoints(partition%neighbours(i,j)))**&
					degvec(m))
			end do
		end if
		fres = (Ri+Rj)/2. - maxval([abs(Ri), abs(Rj)])*(Rj-Ri)/2.

	end function LFflux
	
-----------------------------

	pure function SAT(t) result(bc)

		real(real64), intent(in)				:: t
		real(real64), dimension(:), allocatable	:: bc
		real(real64)							:: F1, FN, tau
		integer, dimension(:), allocatable		:: e1, eN
		integer									:: m, L
		
		allocate(bc(N), e1(N), eN(N))
		L 		= size(R_coeffs, 2)
		e1 		= 0
		e1(1) 	= 1
		eN 		= 0
		eN(N) 	= 1
		F1		= 0
		FN		= 0
		tau		= -1
		do m = 1, L
			F1 = F1 + R_coeffs(1,m)*((-partition%volumes(1)/2.)**degvec(m))
			FN = FN + R_coeffs(N,m)*((partition%volumes(N)/2.)**degvec(m))
		end do
		
		bc = tau*(F1-sin(-2*pi*t))*e1

	end function SAT
	
-----------------------------

pure function rref_kind32(A) result(U)

	real(real32), intent(in), dimension(:,:) 		:: A
	real(real32), dimension(size(A,1),size(A,2)) 	:: L, U, P, temp_u, &
							   						   temp_l, temp_p
	integer 										:: k, i, j, n, m

	m		= size(A,1)
	n 		= size(A,2)
	U 		= A
	temp_u 	= U
	L 		= identity_matrix(m,n)
	temp_l 	= L
	P 		= identity_matrix(m,n)
	temp_p 	= P

	do k = 1, n-1
		i 				= maxloc( U(:, k), dim=1 )
		U(k, k:n) 		= U(i, k:n)
		U(i, k:n) 		= temp_u(k, k:n)
		L(k, 1:k-1) 	= L(i, 1:k-1)
		L(i, 1:k-1) 	= temp_L(k, 1:k-1)
		P(k, :) 		= P(i, :)
		P(i, :) 		= temp_P(k, :)
		do j = k+1, n
		    L(j,k) 		= U(j,k) / U(k,k)
		    U(j, k:n) 	= U(j, k:n) - L(j,k) * U(k, k:n)
		end do
		temp_U = U
		temp_L = L
		temp_P = P
	end do

end function rref_kind32

pure function rref_kind64(A) result(U)

	real(real64), intent(in), dimension(:,:) 		:: A
	real(real64), dimension(size(A,1),size(A,2)) 	:: L, U, P, temp_u, &
							   						   temp_l, temp_p
	integer 										:: k, i, j, n, m

	m		= size(A,1)
	n 		= size(A,2)
	U 		= A
	temp_u 	= U
	L 		= identity_matrix(m,n)
	temp_l 	= L
	P 		= identity_matrix(m,n)
	temp_p 	= P

	do k = 1, n-1
		i 				= maxloc( U(:, k), dim=1 )
		U(k, k:n) 		= U(i, k:n)
		U(i, k:n) 		= temp_u(k, k:n)
		L(k, 1:k-1) 	= L(i, 1:k-1)
		L(i, 1:k-1) 	= temp_L(k, 1:k-1)
		P(k, :) 		= P(i, :)
		P(i, :) 		= temp_P(k, :)
		do j = k+1, n
		    L(j,k) 		= U(j,k) / U(k,k)
		    U(j, k:n) 	= U(j, k:n) - L(j,k) * U(k, k:n)
		end do
		temp_U = U
		temp_L = L
		temp_P = P
	end do

end function rref_kind64

----------------------------

pure function triangle_char_length(points, connectivity_list) result(res)

	real(real64), intent(in), dimension(:,:) 		:: points
	integer, intent(in), dimension(:,:) 			:: connectivity_list
	real(real64), dimension(:), allocatable			:: h_vec
	real(real64)									:: res
	integer											:: N, i
	
	N = size(connectivity_list,1)
	allocate(h_vec(N))
	h_vec = 0
	do i = 1, N
		h_vec(i) = maxval([&
			norm2(points(connectivity_list(i,1),:) - &
				  points(connectivity_list(i,2),:)),&
			norm2(points(connectivity_list(i,2),:) - &
				  points(connectivity_list(i,3),:)),&
			norm2(points(connectivity_list(i,3),:) - &
				  points(connectivity_list(i,1),:))])
	end do
	res = maxval(h_vec)

end function triangle_char_length

---------------------------
pure function triangle_char_length(volumes) result(res)

	real(real64), intent(in), dimension(:) 		:: volumes
	real(real64)								:: res
	integer										:: N, i
	
	N = size(volumes,1)
	res = maxval(volumes)

end function triangle_char_length


-------------------------------

subroutine load_grid(grid)

	type(triangulation) :: grid
	
	call load_to_var('point_list.txt', grid%points, 2)
	call load_to_var('connectivity_list.txt', grid%connectivity_list, 3)
	call load_to_var('edge_list.txt', grid%edge_list, 2)
	grid%barycenters  = triangle_barycenters(grid%points, &
											 grid%connectivity_list)
	grid%volumes 	  = triangle_volumes(grid%points, grid%connectivity_list)
	grid%dual_volumes = node_volumes(grid%points, grid%connectivity_list, &
									 grid%volumes)
	grid%neighbours	  = triangle_neighbours(grid%connectivity_list)
	grid%h			  = triangle_char_length(grid%points,&
											 grid%connectivity_list)
	grid%distancematrix = triangle_distances(grid%barycenters)
	call triangle_fix_orientation(grid%points, grid%connectivity_list)
	
end subroutine load_grid

------------------------------

subroutine load_grid(grid)

	type(triangulation) :: grid
	
	call load_to_var('point_list.txt', grid%points, 2)
	call load_to_var('connectivity_list.txt', grid%connectivity_list, 3)
	call load_to_var('edge_list.txt', grid%edge_list, 2)
	grid%barycenters  = triangle_barycenters(grid%points, &
											 grid%connectivity_list)
	grid%volumes 	  = triangle_volumes(grid%points, grid%connectivity_list)
	grid%dual_volumes = node_volumes(grid%points, grid%connectivity_list, &
									 grid%volumes)
	grid%neighbours	  = triangle_neighbours(grid%connectivity_list)
	grid%h			  = triangle_char_length(grid%volumes)
	grid%distancematrix = triangle_distances(grid%barycenters)
	call triangle_fix_orientation(grid%points, grid%connectivity_list)

end subroutine load_grid


-----------------------------

rdof		= binom(kexact + 2,2)

--------------------------
	pure function centralflux(x, y) result(res)
	
		real(real64), intent(in)	:: x, y
		integer						:: N, m
		real(real64)				:: res, Ri, Rj
		
		N 	= size(R_coeffs,2)
		Ri = 0
		Rj = 0
		do m = 1, N
			Ri = Ri + &
				R_coeffs(i,m)*((x-grid%barycenters(i,1))**degvec(m,1))&
				*((y-grid%barycenters(i,2))**degvec(m,2))
		end do
		if (grid%neighbours(i,j) == 0) then
				Rj  = Ri
		else
			do m = 1, N
				Rj = Rj + &
					R_coeffs(grid%neighbours(i,j),m)&
					*((x-grid%barycenters(grid%neighbours(i,j),1))&
					**degvec(m,1))&
					*((y-grid%barycenters(grid%neighbours(i,j),2))**degvec(m,2))
			end do
		end if
		res = (Ri+Rj)/2.
		if(grid%points(grid%connectivity_list(i,j),1) == 0) then
			res = sin(2*pi*(grid%points(grid%connectivity_list(i,j),2)/2.-t))
		end if
		if(grid%points(grid%connectivity_list(i,j),2) == 0) then
			res = sin(2*pi*(grid%points(grid%connectivity_list(i,j),1)/2.-t))
		end if
		

	end function centralflux
	
-----------------------------

pure function triangle_volumes(points, connectivity_list) result(volumes)

	real(real64), intent(in), dimension(:,:)	:: points
	integer, intent(in), dimension(:,:) 		:: connectivity_list
	real(real64), dimension(:), allocatable		:: volumes
	integer										:: N, i
	
	N = size(connectivity_list,1)
	allocate (volumes(N))
	do i = 1, N
		volumes(i) = (1./2.)*abs(points(connectivity_list(i,1),1)*&
						(points(connectivity_list(i,2),2)-&
						points(connectivity_list(i,3),2))+&
						points(connectivity_list(i,2),1)*&
						(points(connectivity_list(i,3),2)-&
						points(connectivity_list(i,1),2))+&
						points(connectivity_list(i,3),1)*&
						(points(connectivity_list(i,1),2)-&
						points(connectivity_list(i,2),2)))
	end do

end function triangle_volumes

-------------------------

program test

    use iso_fortran_env, only: real32, real64, int8, int16, int32
    use mod_data_manip
    use mod_derived_types
    use mod_io
	use mod_linalg
    implicit none

	!second order node-centered FVM
	!u_t + u_x + u_y = 0
	!u(x,y,0) = sin(2pi(x/2 + y/2))
	!u(0,y,t) = sin(2pi(y/2 - t))
	!u(x,0,t) = sin(2pi(x/2 - t))

	type(triangulation) 							:: grid
	integer											:: i, j, N, m, timesteps
	integer, dimension(:,:), allocatable 			:: neighbours
	integer, dimension(:), allocatable				:: boundaryvolumes
	real(real64), dimension(:,:), allocatable		:: Qx, Qy, V, invV, &
														dx, dy
	real(real64), dimension(:), allocatable			:: u, a_1, a_2, a_3, a_4, &
	 													exactsol
	real(real64), dimension(1,2)					:: p1, p2
	real(real64)									:: tmin, tmax, t
	real(real64)									:: error, k, h, pi
	
	pi = 4.D0*DATAN(1.D0)
	
	!load the spatial grid
	call load_grid(grid)
	N 		= size(grid%points,1)
	h 		= grid%h
	allocate(V(N,N), invV(N,N))
	V 		= 0
	invV 	= 0
	do i = 1, N
		V(i,i) = grid%dual_volumes(i)
		invV(i,i) = 1/V(i,i)
	end do
	
	!set up problem
	k 			= h/2.
	t			= 0
	tmax 		= 1
	tmin 		= 0
	timesteps 	= floor((tmax-tmin)/k)
	k 			= (tmax-tmin)/timesteps
	allocate (u(N))
	do i = 1, N
		u(i) = sin(2*pi*(grid%points(i,1)/2. + grid%points(i,2)/2.))
	end do
	
	!define neighbours(i,j) = 1 if p_i and p_j are connected
	allocate(neighbours(N,N))
	neighbours = 0
	do i = 1, size(grid%edge_list,1)
		neighbours(grid%edge_list(i,1),grid%edge_list(i,2)) = 1
		neighbours(grid%edge_list(i,2),grid%edge_list(i,1)) = 1
	end do
	
	!find delta x_ij, delta y_ij with correct sign
	allocate(Qx(N,N), Qy(N,N), dx(N,N), dy(N,N))
	Qx = 0
	Qy = 0
	dx = 0
	dy = 0
	do i = 1, N
		do j = 1, N
			if (neighbours(i,j) == 1) then
				p1 = 0
				p2 = 0
				do m = 1, size(grid%connectivity_list,1)
					if ((i == grid%connectivity_list(m, 1)   .or. &
						i == grid%connectivity_list(m, 2)    .or. &
						i == grid%connectivity_list(m, 3))   .and.&
						(j == grid%connectivity_list(m, 1) 	 .or. &
						j == grid%connectivity_list(m, 2)    .or. &
						j == grid%connectivity_list(m, 3)))  then
						if (p1(1,1) == 0 .and. p1(1,2) == 0) then
							p1(1,1) = grid%barycenters(m, 1)
							p1(1,2) = grid%barycenters(m, 2)
						else
							p2(1,1) = grid%barycenters(m, 1)
							p2(1,2) = grid%barycenters(m, 2)
						end if
					end if
				end do
				dx(i,j) = abs(p2(1,1)-p1(1,1))
				dy(i,j) = abs(p2(1,2)-p1(1,2))
				if (grid%points(i,2) < grid%points(j,2) .or.&
					(grid%points(i,2) == grid%points(j,2)) .and.&
					(grid%points(i,1) > grid%points(j,1) .and.&
					(p1(1,2) > p2(1,2) .and. p1(1,1) < p2(1,1)) .or.&
					(p2(1,2) > p1(1,2) .and. p2(1,1) < p1(1,1))) .or.&
					(grid%points(i,1) < grid%points(j,1) .and.&
					(p1(1,2) < p2(1,2) .and. p1(1,1) > p2(1,1)) .or.&
					(p2(1,2) < p1(1,2) .and. p2(1,1) > p1(1,1)))) then 
						dx(i,j) = -dx(i,j)
				end if
				if (grid%points(i,1) > grid%points(j,1) .or.&
					(grid%points(i,1) == grid%points(j,1)) .and.&
					(grid%points(i,2) > grid%points(j,2) .and.&
					(p1(1,1) < p2(1,1) .and. p1(1,2) > p2(1,2)) .or.&
					(p2(1,1) < p1(1,1) .and. p2(1,2) > p1(1,2))) .or.&
					(grid%points(i,2) < grid%points(j,2) .and.&
					(p1(1,1) > p2(1,1) .and. p1(1,2) > p2(1,2)) .or.&
					(p2(1,1) > p1(1,1) .and. p2(1,2) > p1(1,2)))) then
						dy(i,j) = -dy(i,j)
				end if
				Qy(i,j) = -dx(i,j)/2.
				Qx(i,j) = dy(i,j)/2.
			end if
		end do
	end do
	
	!if the row sum in Qx or Qy is not equal to zero, the row corresponds to
	!a boundary volume
	allocate (boundaryvolumes(N))
	boundaryvolumes = 0
	do i = 1, N
		if (abs(sum(Qx(i,:))) > 1e-5) then
			Qx(i,i) = -sum(Qx(i,:))
		else if (abs(sum(Qy(i,:))) > 1e-5) then
			Qy(i,i) = -sum(Qy(i,:))
		end if
	end do
	
	!time stepping
	allocate (a_1(N), a_2(N), a_3(N), a_4(N))
	do i = 1, timesteps
		t = (i-1)*k
		
		a_1 = -matmul(invV, matmul(Qx,u)) - matmul(invV, matmul(Qy,u)) + &
				matmul(invV, SAT(t))
		a_2 = -matmul(invV,matmul(Qx, u + a_1*(k/2.))) 	- &
				matmul(invV, matmul(Qy, u + a_1*(k/2.))) + &
				matmul(invV, SAT(t + k/2.))
		a_3 = -matmul(invV,matmul(Qx, u + a_2*(k/2.)))	- &
				matmul(invV,matmul(Qy, u + a_2*(k/2.))) 	+ &
				matmul(invV, SAT(t + k/2.))
		a_4 = -matmul(invV,matmul(Qx, u + a_3*k)) 	 	- &
				matmul(invV,matmul(Qy, u + a_3*k)) 		+ &
				matmul(invV, SAT(t + k))
		
		u 	= u + (k/6)*(a_1 + 2*a_2 + 2*a_3 + a_4)
	end do
	
	!convergence analysis
	allocate (exactsol(N))
	exactsol(1:N) = sin(2*pi*(grid%points(1:N,1)/2. + grid%points(1:N,2)/2.-tmax))
	error = sqrt(dot_product(exactsol-u, matmul(V, exactsol-u)))
	print*, 'Error at t = ', t, 'is', error
	

contains

pure function g_1(y, t) result(bc)

	real(real64), intent(in) :: t, y
	real(real64)			 :: bc
	
	bc = sin(2.*pi*(y/2. - t))

end function g_1

pure function g_2(x, t) result(bc)

	real(real64), intent(in) :: t, x
	real(real64)			 :: bc
	
	bc = sin(2.*pi*(x/2. - t))

end function g_2

pure function SAT(t) result(res)

	real(real64), intent(in) 	:: t
	real(real64), dimension(N) 	:: res
	integer						:: i
	
	res = 0
	do i = 1, N
		if (grid%points(i,1) == 0) then
			res(i) = (u(i)-g_1(grid%points(i,2),t))*(Qx(i,i)-Qy(i,i))/2.
		else if (grid%points(i,2) == 0) then
			res(i) = (u(i)-g_2(grid%points(i,1),t))*(Qx(i,i)-Qy(i,i))/2.
		end if
	end do

end function SAT

end program test

--------------------------

program test2

	use mod_linalg
	use mod_io
	implicit none
	
	real(real64), dimension(:,:), allocatable :: A
	real(real64), dimension(:), allocatable	  :: b, x
	real(real64)							  :: res
	integer							  		  :: m, n
	
	m = 6
	n = 3
	allocate (A(m,n), b(m), x(n))
	A(:,1) = [2.5, 0., 0., 1., 1., 23.]
	A(:,2) = [45., 2., 15., 2., 12., 45.]
	A(:,3) = [100., 0., 23., 5., 1., 1.]
	b = [15., 2., 3., 4., 5., 6.]
	
	!x = least_squares_qr(A,b)
	x = constrained_least_squares(A, b)
	res = dot_product(A(1,:),x)
	print*, res
	call write_to_file(x, 5)
	call write_to_file(matmul(A, x), 6)
	
	
end program test2

-------------------------------

!simple test

program test2

	use mod_quadrature
	use mod_io
	implicit none
	
	integer :: degree
	real 	:: integralvalue
	
	degree = 4
	integralvalue = gauss_legendre(degree, f)
	print*, integralvalue 
	
	!true solution = 1.71124878378430...
	!works fine.
	
contains

pure function f(x) result (res)

	real, intent(in) :: x
	real			 :: res
	res = exp(-(x**2.)/2.)

end function f
	
end program test2

-------------------

!simple test 2

program test2

	use mod_quadrature
	use mod_io
	implicit none
	
	integer :: degree
	real 	:: integralvalue, a, b

	a = 1
	b = 2	
	degree = 4
	integralvalue = transformed_gauss_legendre(a, b, degree, g)
	print*, integralvalue 
	
	!true solution = 0.3862943611..
	!works fine.
	
contains

pure function f(x) result (res)

	real, intent(in) :: x
	real			 :: res
	res = exp(-(x**2.)/2.)

end function f

pure function g(x) result(res)

	real, intent(in) :: x
	real			 :: res
	res = log(x)

end function g
	
end program test2

------------------

----------------------
! test arnoldi_iteration

    real, dimension(10,10) :: A
    real, dimension(:,:), allocatable :: Q, H, H_n
    integer :: i, n = 5

    allocate(Q(size(A,1), n+1), H(n+1, n), H_n(n, n))

    A = -192
    do i = 1, size(A,2)
        A(i,i) = 4
    end do
    A(1,2) = 2

    call arnoldi_iteration(A, n, Q, H)
    call write_to_file(Q, 1)
    call write_to_file(H, 2)

    H_n = H(1:n, 1:n)
    call write_to_file(H_n, 3)

---------------------
program test2

	use mod_linalg
	use mod_io
	implicit none
	
	real, dimension(3,2) :: A
	real, dimension(:,:), allocatable :: Q, R
	real, dimension(3) :: b
	real, dimension(:), allocatable :: x
	
	!test reduced qr decomposition
	
	A(1,:) = [1., -4.]
	A(2,:) = [2., 3.]
	A(3,:) = [2., 2.]
	b 	= [-3., 15., 9.]
	
	allocate(x(2))
	x = least_squares_qr(A, b)
	print*, x
	
	allocate (Q(3,2), R(2,2))
	call reduced_qr_decomposition(A,Q,R)
	call write_to_file(A,1)
	call write_to_file(Q,2)
	call write_to_file(R,3)
	call write_to_file(matmul(Q, R),4)
	
end program test2
-------------------
program test2

	use mod_linalg
	use mod_io
	implicit none
	
	real, dimension(:,:), allocatable :: A, Q, R
	integer							  :: m, n
	
	m = 8
	n = 3
	allocate (A(m,n), Q(m,n), R(n,n))
	A(:,1) = [4., 2., 6., 52., 1., 21., 2., 67.]
	A(:,2) = [25., 1., 3., 3., 8., 17., 13., 82.]
	A(:,3) = [93., 52., 51., 2., 23., 74., 23., 1.]
	call write_to_file(A, 1)
	
	call reduced_qr_decomposition(A, Q, R)
	call write_to_file(Q, 2)
	call write_to_file(R, 3)
	call write_to_file(matmul(Q, R), 4)
	
end program test2
---------------------
program test3
	
	use iso_fortran_env, only: real32, real64
	use mod_io
	use mod_linalg
	implicit none

    real(real64), dimension(10,10) :: A
    real(real64), dimension(:,:), allocatable :: Q, R
    integer :: i

	! test qr_decomposition
    allocate( Q(size(A,1), size(A,2)), R(size(A,1), size(A,2)) )
    A = -192
    do i = 1, size(A,2)
        A(i,i) = 4
    end do
    A(1,2) = 2

    call qr_decomposition(A, Q, R)
    call write_to_file(Q, 1)
    call write_to_file(R, 2)
    call write_to_file(matmul(Q, R), 3)
    call write_to_file(A, 4)
    
end program test3


---------------------
! test qr_algorithm

    real(real64), dimension(:,:), allocatable :: A, A_schur
    integer :: i, n = 3

    allocate( A(n,n), A_schur(n,n))
	
	!Eig val should be 4, 2, 1
	
    A(1,:) = [0, 11, -5]
    A(2,:) = [-2, 17, -7]
    A(3,:) = [-4, 26, -10]

    A_schur = qr_algorithm(A)

    call write_to_file(A_schur, 1)

	deallocate( A, A_schur )

-----------
! test backwards_subst

    real(real64), dimension(:,:), allocatable :: R
    real(real64), dimension(:), allocatable :: b, x  
    integer :: i, n = 5

    allocate( R(n,n), b(n), x(n))

    R = 0
    do i = 1, n
        R(i,i:n) = 24
    end do
    R(1,2) = 14
    R(1,3) = -332
    R(2,3) = 45
    R(3,4) = -99
    R(n,n) = 13

    b = 13

    x = backwards_subst(R,b)

    call write_to_file(R, 1)
    call write_to_file(matmul(R,x), 2)
    call write_to_file(b, 3)

-------------
! test upper_hessenberg

    real(real64), dimension(10,10) :: A, H
    integer :: i

    A = -192
    do i = 1, size(A,2)
        A(i,i) = 4
    end do
    A(1,2) = 2
    A(9,2) = 5
    A(9,7) = 2784

    H = upper_hessenberg(A)

    call write_to_file(H,1)

-----------------------
! test shifted_iteration

    real(real64), dimension(:,:), allocatable :: A, A_schur, lambda, R, AR, lambdaR
    integer :: i, n = 3

    allocate( A(n,n), A_schur(n,n), lambda(n,n), R(n,n), AR(n,n), lambdaR(n,n))

    !EIGENVALUES SHOULD BE 4, 2, 1 -- We find the correct eigenvalues
    A(1,:) = [0, 11, -5]
    A(2,:) = [-2, 17, -7]
    A(3,:) = [-4, 26, -10]
 
    A_schur = qr_algorithm(A)

    call write_to_file(A_schur, 1)

    lambda = 0
    do i = 1, n
        lambda(i,i) = A_schur(i,i)
    end do

    lambda = high_to_low_diag(lambda)
    call write_to_file(lambda, 2)

    !something goes wrong after this point

    R = shifted_iteration(A,lambda)

    call write_to_file(R,3)

    !Test R(:,i) * lambda(i,i) = A * R(:,i) (verify eigenvec and eigenval)
    do i = 1, n
        AR = matmul(A, R)
        lambdaR(:,i) = lambda(i,i) * R(:,i)
    end do

    call write_to_file(AR, 4)
    call write_to_file(lambdaR, 5)

--------------------------------
! test gaussian_elim

    real(real64), dimension(:,:), allocatable :: A
    real(real64), dimension(:), allocatable :: b, x  
    integer :: i, n = 20

    allocate( A(n,n), b(n), x(n))

    A = 215
    do i = 1, n
        A(i,i:n) = 24
    end do
    A(n,n) = 13
    A(1,2) = -115
    A(1,3) = 0
    A(2,2) = -99

    b(1:n) = [(i, i = 1, n)]

    x = gaussian_elim(A,b)
    
    call write_to_file(x, 1)
    call write_to_file(matmul(A,x), 2)
    call write_to_file(b, 3)

---------------------------------
! test forwards_subst

    real(real64), dimension(:,:), allocatable :: L
    real(real64), dimension(:), allocatable :: b, x
    integer :: i, n

    n = 5
    allocate( L(n,n), b(n), x(n))

    L = 0
    do i = 1, n
        L(i,i) = 2
    end do
    L(2,1) = -53
    L(3,1) = 31
    L(3,2) = -885
    L(4,1) = 8
    L(4,2) = 79
    L(4,3) = -44

    b(1:n) = [(i, i = 1,n)] 
    x = forwards_subst(L, b)

    call write_to_file(L, 1)
    call write_to_file(matmul(L, x), 2)
    call write_to_file(b, 3)

-----------------------------

! test least_squares_qr

    real(real64), dimension(:,:), allocatable :: A, Q, H, R, L, U
    real(real64), dimension(:), allocatable :: x, b, v
    integer :: i, m, n, k, j

    m = 10
    n = 9

    allocate(A(m, n), Q(m,n), R(n,n), x(m), b(m))

    A = 15
    do i = 1, n
        do j = 1, m
            A(j, i) = i*j
        end do
    end do
    A(1:3, 1) = 159
    A(10, 9) = -5

    call write_to_file(A, 1)

    b = 99

    x = least_squares_qr(A, b)

    call write_to_file(x, 2)
    call write_to_file(matmul(A, x), 3)

